const { constants } = require('./constants');
const { isSuccessStatusCode, processResponse } = require('./utility');
const fetch = require('node-fetch');

module.exports.getGists = (token, username) => {
  return fetch(`${constants.githubApiBaseUrl}/users/${username}/gists`, {
    headers: {
      'Authorization': token
    }
  }).then(res => processResponse(res));
}

module.exports.getLayoutGist = (token, username) => {
  return this.getGists(token, username)
    .then(gists => {
      const gist = gists.find(gist => gist.description === constants.gistDescription);

      if(!gist) {
        throw new Error('Gist not found.');
      } else {
        return gist;
      }
    });
}

module.exports.createGist = (token, content) => {

  return fetch(`${constants.githubApiBaseUrl}/gists`, {
    method: 'POST',
    headers: {
      'Authorization': token
    },
    body: JSON.stringify({
      description: constants.gistDescription,
      public: true,
      files: {
        'artisan-wants.json': {
          content
        }
      }
    })
  }).then(res => {
    console.log(res.status);
    if(!isSuccessStatusCode(res.status)) {
      throw new Error();
    }
    return res.json();
  });
}

module.exports.updateGist = (token, id, content) => {
  return fetch(`${constants.githubApiBaseUrl}/gists/${id}`, {
    method: 'PATCH',
    headers: {
      'Authorization': token
    },
    body: JSON.stringify({
      files: {
        'artisan-wants.json': {
          content
        }
      }
    })
  }).then(res => {
    console.log(res.status);
    if(!isSuccessStatusCode(res.status)) {
      throw new Error();
    }
    return res.json();
  });
}

module.exports.getUser = (token) => {
  return fetch(`${constants.githubApiBaseUrl}/user`, {
      method: 'GET',
      headers: {
          'Authorization': token,
          'Accept': 'application/json'
      }
  })
  .then(res => res.json());
}

module.exports.getPublicRepositories = (token, username) => {
  return fetch(`${constants.githubApiBaseUrl}/users/${username}/repos`, {
    method: 'GET',
    headers: {
      'Authorization': token
    }
    
  })
  .then(res => {
    if(!isSuccessStatusCode(res.status)) {
      throw new Error();
    }
    return res.json();
  });
}

module.exports.createRepo = (token, username) => {
  return fetch(`${constants.githubApiBaseUrl}/user/repos`, {
    method: 'POST',
    headers: {
      'Authorization': token,
      'Content-Type': 'application/json'
    },
    body: JSON.stringify({
      name: `${username}.github.io`,
      private: false,
      description: 'Automatically generated by Artisan Wants List Generator.',
      auto_init: true
    })
  })
  .then(res => {
    if(!isSuccessStatusCode(res.status)) {
      throw new Error();
    }
    return res.json();
  });
}

module.exports.getGistData = (url) => {
  return fetch(url)
    .then(res => processResponse(res));
}

module.exports.createBlob = (token, username, content) => {
  return fetch(`${constants.githubApiBaseUrl}/repos/${username}/${username}.github.io/git/blobs`, {
      method: 'POST',
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        content,
        encoding: 'utf-8'
      })
    })
    .then(res => processResponse(res));
}

module.exports.commitFiles = (token, username, htmlSha, cssSha) => {
  return getReferenceToHead(token, username)
    .then(data => {
      return getHeadCommit(data.object);
    })
    .then(headCommit => {
      const headCommitSha = headCommit.sha;

      return getHeadCommitTree(headCommit.tree, token, username)
        .then(headCommitTree => {
          return createTree(headCommitTree.sha, token, username, htmlSha, cssSha);
        })
        .then(newTree => {
          return createCommit(newTree.sha, headCommitSha, token, username);
        })
        .then(newCommit => {
          return updateHeadReference(newCommit.sha, token, username);
        })
        .then(headRef => {
          console.log(headRef);
        });
    });
}

function getReferenceToHead(token, username) {
  return fetch(`${constants.githubApiBaseUrl}/repos/${username}/${username}.github.io/git/refs/heads/master`, {
      headers: {
        'Authorization': token
      },
    })
    .then(res => processResponse(res));
}

function getHeadCommit(object, token, username) {
  return fetch(object.url)
    .then(res => processResponse(res));
}

function getHeadCommitTree(tree, token, username) {
  return fetch(tree.url)
    .then(res => processResponse(res));
}

function createTree(baseTreeSha, token, username, htmlSha, cssSha) {
  return fetch(`${constants.githubApiBaseUrl}/repos/${username}/${username}.github.io/git/trees`, {
      method: 'POST',
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        base_tree: baseTreeSha,
        tree: [
          {
            path: 'index.html',
            mode: '100644',
            type: 'blob',
            sha: htmlSha
          },
          {
            path: 'styles.css',
            mode: '100644',
            type: 'blob',
            sha: cssSha
          }
        ]
      })
    })
    .then(res => processResponse(res));
}

function createCommit(treeSha, parentCommitSha, token, username) {
  return fetch(`${constants.githubApiBaseUrl}/repos/${username}/${username}.github.io/git/commits`, {
      method: 'POST',
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        message: `Commit generated by Artisan Wants Generator at ${new Date().toUTCString()}`,
        parents: [parentCommitSha],
        tree: treeSha
      })
    })
    .then(res => processResponse(res));
}

function updateHeadReference(newCommitSha, token, username) {
  return fetch(`${constants.githubApiBaseUrl}/repos/${username}/${username}.github.io/git/refs/heads/master`, {
      method: 'PATCH',
      headers: {
        'Authorization': token,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({
        sha: newCommitSha,
        force: true
      })
    })
    .then(res => processResponse(res));
}